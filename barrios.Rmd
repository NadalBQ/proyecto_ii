---
title: "Barrios"
author: "Toni"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# LIBRERÍAS
```{r}
library(sf)
library(dplyr)
library(geosphere)
library(leaflet)
```

# CARGA Y CREACIÓN DE FICHEROS
Para continuar con el proyecto se han obtenido nuevas bases de datos para añadir información sobre los barrios y poder agrupar los barrios en función de como afectan estas nuevas variables al precio ponderado obtenido anteriormente.

Se han obtenido 3 nuevos datasets, uno de transporte público por barrio, obtenido de la página del ayuntamiento, otro de renta media obtenido en la página del INE y otro de distancias a lugares de interés que se ha obtenido calculando las distancias a partir del fichero geojson de valencia y las coordenadas de cada lugar.

Primero se procederá a leer los archivos de pisos del estudio anterior y transporte:
```{r pisos y transporte}
pisos = read.csv('pisos_filtrados.csv', sep =';')
transporte = read.csv('transporte.csv', sep = ';')
```

A continuación se va a calcular los centroides de cada barrio a partir del geojson para así poder calcular la distancia exacta del centro del barrio al lugar de interés:
```{r centroides barrios}
# Cargar el geojson
barrios <- st_read("valencia.geojson")

# Obtener centroides de los polígonos
barrios_centroides <- barrios %>% 
  mutate(centroide = st_centroid(geometry)) %>%
  mutate(lon = st_coordinates(centroide)[,1],
         lat = st_coordinates(centroide)[,2])

```
Ahora se crea un nuevo fichero con los puntos clave que se han elegido para el estudio:
```{r lugares de interés}
# Lista de puntos clave con nombre, latitud y longitud
puntos_clave <- data.frame(
  nombre = c("Plaza_Ayuntamiento", "CAC", "Bioparc", "Estacion_Norte", 
             "Playa_Malvarrosa", "Torres_Serranos", "Universitat", 
             "Puerto", "Albufera", "Viveros", "Parque_Cabecera", 'UPV', "Mestalla"),
  lat = c(39.4699, 39.4554, 39.4781, 39.4652, 
          39.4831, 39.4793, 39.4754, 
          39.4515, 39.3331, 39.4818, 39.4747, 39.4823, 39.4748),
  lon = c(-0.3763, -0.3537, -0.4008, -0.3767, 
          -0.3282, -0.3758, -0.3445, 
          -0.3160, -0.3356, -0.3677, -0.4083, -0.3435, -0.3574)
)
```

Para comprobar que las coordenadas son correctas se muestran en un mapa:
```{r mapa lugares}

lugares_sf <- st_as_sf(puntos_clave, coords = c("lon", "lat"), crs = 4326)

# 4. Crear mapa interactivo
leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  addPolygons(data = barrios, 
              color = "#444444", 
              weight = 1, 
              fillOpacity = 0.3,
              label = ~as.character(nombre),  # o el campo correcto para nombre de barrio
              highlightOptions = highlightOptions(weight = 2, color = "blue", fillOpacity = 0.5)) %>%
  addCircleMarkers(data = lugares_sf, 
                   radius = 6, 
                   color = "red", 
                   fillOpacity = 0.9,
                   label = ~nombre,
                   popup = ~nombre)

```
  Efectivamente cada lugar se muestra donde corresponde por lo que se puede continuar con el estudio.
  
Finalmente se calculan las distancias en km para cada barrio a cada punto de interés mediante la función distHaversine y se crea el nuevo dataset de distancias:
```{r distancias}
# Función para calcular distancia entre dos coordenadas
calcular_distancias <- function(lat_barrio, lon_barrio, puntos) {
  distHaversine(matrix(c(lon_barrio, lat_barrio), ncol = 2), 
                matrix(c(puntos$lon, puntos$lat), ncol = 2)) / 1000  # en km
}

# Añadir distancias al dataframe de barrios
distancias <- barrios_centroides %>%
  rowwise() %>%
  mutate(across(c(lat, lon), as.numeric)) %>%
  mutate(
    distancia_P_Ayuntamiento = calcular_distancias(lat, lon, puntos_clave[1,]),
    distancia_CAC           = calcular_distancias(lat, lon, puntos_clave[2,]),
    distancia_Bioparc       = calcular_distancias(lat, lon, puntos_clave[3,]),
    distancia_Estacion      = calcular_distancias(lat, lon, puntos_clave[4,]),
    distancia_Malvarrosa    = calcular_distancias(lat, lon, puntos_clave[5,]),
    distancia_Torres        = calcular_distancias(lat, lon, puntos_clave[6,]),
    distancia_UV   = calcular_distancias(lat, lon, puntos_clave[7,]),
    distancia_Puerto        = calcular_distancias(lat, lon, puntos_clave[8,]),
    distancia_Albufera      = calcular_distancias(lat, lon, puntos_clave[9,]),
    distancia_Viveros      = calcular_distancias(lat, lon, puntos_clave[10,]),
    distancia_Cabecera      = calcular_distancias(lat, lon, puntos_clave[11,]),
    distancia_UPV      = calcular_distancias(lat, lon, puntos_clave[12,]),
    distancia_Mestalla = calcular_distancias(lat, lon, puntos_clave[13,])
  ) %>%
  ungroup()
```

Como en el fichero hay variables no deseadas del geojson se filtra para que sea más cómodo de usar:
```{r filtrar distancias}
distancias_filtrado = distancias %>% select(nombre, distancia_P_Ayuntamiento:last_col())
```

```{r distancias final}
distancias_f <- st_drop_geometry(distancias_filtrado)
```

Una vez obtenidas las distancias, se carga el fichero de renta media:
```{r renta}
renta_media = read.csv("ineValenciafinal.csv", sep =";")
head(renta_media)
```
# DATASET BARRIOS
En este apartado se procede a la creación del dataset final de barrios, primero se va a juntar la información del dataset pisos con el de distancias, para ello, como se va a juntar por barrio, se comprueba si algún barrio presente en pisos no se encuentra en distancias:

```{r dif pisos y distancias}
setdiff(unique(pisos$neighbourhood_cleansed), unique(distancias_f$nombre)
)
```

Se muestra el barrio Mont-Olivet, vamos a ver si realmente no se encuentra en distancias:
```{r barrios distancias}
unique(distancias_f$nombre)
```

Se puede observar que si se encuentra en el fichero, solo que en el de pisos es MONT-OLIVET y en el de distancias es MONTOLIVET, por lo que se le añade el guión:

```{r cambio de nombre}
distancias_f$nombre[distancias_f$nombre == "MONTOLIVET"] <- "MONT-OLIVET"
```

Ahora sí se pueden juntar ambos ficheros, pero antes creamos el fichero barrios_info con la variable barrio y la media de la variable precio_ponderado por cada barrio. Como la variable precio_ponderado daba problemas al estar indicada como carácter, se convierte en numérica y así poder calcular la media:
```{r precio ponderado barrios}
# Paso 3: cambiar coma decimal por punto
pisos$precio_ponderado <- gsub(",", ".", pisos$precio_ponderado)

# Paso 4: convertir a numérico
pisos$precio_ponderado <- as.numeric(pisos$precio_ponderado)

barrios_info <- pisos %>%
  group_by(neighbourhood_group_cleansed, neighbourhood_cleansed) %>%
  summarise(
    media = mean(precio_ponderado, na.rm = TRUE)
  ) %>%
  arrange(desc(media))
```

A continuación le añadimos las distancias:
```{r join barriosxdistancias}
barrios_info <- barrios_info %>%
  left_join(distancias_f, by = c("neighbourhood_cleansed" = "nombre"))
```

Se realiza el mismo procedimiento con el fichero transporte, se comprueba si algún barrio no está presente en transportes:
```{r dif barrios transporte}
setdiff(unique(barrios_info$neighbourhood_cleansed), unique(transporte$nombre))
```

Como todos los barrios están presentes, se unen ambos ficheros con las variables que se desean usar de transporte y se eliminan los ausentes:
```{r transporte resumen}
library(tidyr)

transporte_clean <- transporte %>%
  filter(!is.na(transporte) & transporte != "")  # elimina filas sin tipo transporte

transporte_resumen <- transporte_clean %>%
  group_by(nombre, codbarrio, coddistrit, transporte) %>%
  summarise(conteo = n(), .groups = "drop") %>%
  pivot_wider(
    names_from = transporte,
    values_from = conteo,
    values_fill = 0
  )
```

```{r join barriosxtransporte}
barrios_info <- barrios_info %>%
  left_join(transporte_resumen, by = c("neighbourhood_cleansed" = "nombre"))
```

Por último se va a proceder a juntar el fichero de renta_media, como en este los nombres de barrios no coinciden con el fichero de barrios hay que juntarlo de otra forma. Con el fichero de transporte se han unido las variables codbarrio y coddistrit, también presentes en renta_media, para ver si coinciden se comprueba si algún par (distrito, barrio) en renta_media no está presente en barrio_info:

```{r pares únicos}
# Pairs únicos en barrios_info
pares_barrios_info <- barrios_info %>%
  select(coddistrit, codbarrio) %>%
  distinct()

# Pairs únicos en renta_media (ajusta nombres según tu dataset)
pares_renta_media <- renta_media %>%
  select(Codigo_Distrito, Codigo_Barrio) %>%
  distinct()
```

```{r diferencias}
diferencias <- anti_join(pares_barrios_info, pares_renta_media,
                         by = c("coddistrit" = "Codigo_Distrito", 
                                "codbarrio" = "Codigo_Barrio"))
head(diferencias)
```

Como no hay ninguna diferencia se pueden juntar sin problema ambas bases de datos con las variables de renta_media que se desean:
```{r join barriosxrenta}
renta_media_seleccion <- renta_media %>%
  group_by(Codigo_Distrito, Codigo_Barrio) %>%
  summarise(
    X2022_persona = mean(X2022_persona, na.rm = TRUE),
    X2022_hogar = mean(X2022_hogar, na.rm = TRUE)
  ) %>%
  ungroup()

barrios_info <- barrios_info %>%
  left_join(renta_media_seleccion, by = c("coddistrit" = "Codigo_Distrito", 
                                          "codbarrio" = "Codigo_Barrio"))

```

Finalmente se cambian los nombres del fichero por otros más orientativos:
```{r cambio nombres}
barrios_info <- barrios_info %>%
  rename(
    distrito = neighbourhood_group_cleansed,
    barrio = neighbourhood_cleansed,
    precio = media,
    coddistrito = coddistrit,
    renta_persona = X2022_persona,
    renta_hogar = X2022_hogar
  )

head(barrios_info)
```


Ahora ya se puede continuar con el estudio de agrupamiento de barrios.

# INFLUENCIA DE LAS NUEVAS VARIABLES EN EL PRECIO PONDERADO

